---
title: "Customer Data Analysis"
output: html_notebook
---

We want to analyze our customer data, and better understand them.  Please identify:

```{r setup}
load('exerciseData.rda')
```
* The top 10 email_cols by active enterprise users
```{r}
library(dplyr)

# many to many
# dataset_emails$email_col
# dataset_tenants$tenant_col

combine_email_and_tenant_data <- function(relation, emails, tenants, email_col_num, tenant_col_num){
    # save the column names for later
    old_email_name <- colnames(emails)[email_col_num]
    old_tenant_name <- colnames(tenants)[tenant_col_num]
    
    # rename the columns for ease of reference
    colnames(emails)[email_col_num] <- "email_col"
    colnames(tenants)[tenant_col_num] <- "tenant_col"
    
    # create a joined table of tenants and emails
    email_tenant <- left_join(relation, tenants, by='tenant_id') %>%
        left_join(., emails, by='email_id') %>%
        select(tenant_id, email_col, tenant_col) #%>%
    
    # remove non-zero tenant_col, sort by tenant_col and then tenant id, and remove NULL rows
    email_tenant <- email_tenant[email_tenant$tenant_col > 0,]
    email_tenant <- arrange(email_tenant,desc(tenant_col), tenant_id)
    email_tenant <- email_tenant[complete.cases(email_tenant), ]
    
    # get a count of unique tenants and create an empty matrix to hold the deduped data
    unique_tenants <- unique(email_tenant$tenant_id)
    result <- matrix(NA, nrow=length(unique_tenants), ncol=2, dimnames=list(NULL, c("email_col", "tenant_col")))
    
    # create temporary vectors to loop through, as well as placeholder looping variables
    tenant_ids <- data.matrix(email_tenant$tenant_id, rownames.force = NA)
    email_cols <- data.matrix(email_tenant$email_col, rownames.force = NA)
    tenant_cols <- data.matrix(email_tenant$tenant_col, rownames.force = NA)
    temp_email_cols <- email_cols[1]
    temp_tenant_col <- tenant_cols[1]
    index <- 1
    
    # for a given tenant, make a list of all associated email_cols, find the mode,
    # and attribute those tenant_cols to that email_col
    for (i in 2:length(tenant_ids)){
        if (tenant_ids[i] != tenant_ids[i-1]){
            # get the most frequent email_col from temp list AKA temp_email_cols.mode()
            most_freq_email_col <- names(sort(summary(as.factor(temp_email_cols)), decreasing=T)[1])
            # add it to the matrix
            result[index, 1] <- most_freq_email_col
            # add tenant_col to the matrix
            result[index, 2] <- temp_tenant_col
            # advance index
            index <- index + 1
            # set list of email_cols for next tenant and set temp tenant_col
            temp_email_cols <- email_cols[i]
            temp_tenant_col <- tenant_cols[i]
        } else {
            # add email_col to list of email_cols for a given tenant
            temp_email_cols <- append(temp_email_cols, email_cols[i])
        }
    }
    # remove null rows
    result <- result[complete.cases(result), ]
    result <- as.data.frame(result)
    
    # convert to numeric values and group by email_col, then sort by tenant_col
    result$tenant_col <- as.numeric(as.character(result$tenant_col))
    result <- group_by(result, email_col) %>%
        summarise(tenant_col = sum(tenant_col)) %>%
        arrange(desc(tenant_col))
    
    colnames(result)[1] <- old_email_name
    colnames(result)[2] <- old_tenant_name
    return(result)
}
country_activeusers <- combine_email_and_tenant_data(dataset_relation, dataset_emails, dataset_tenants, 3, 6)
head(country_activeusers, n = 10)
```
* The top 10 operating systems by open and total tickets
```{r}
#many to many
#dataset_emails$sperating_system
#dataset_tenants$account_open_tickets
#dataset_tenants$account_total_tickets

# use function from previous exercise
operatingsystem_opentickets <- combine_email_and_tenant_data(dataset_relation, dataset_emails, dataset_tenants, 8, 12)
head(operatingsystem_opentickets, n = 10)

operatingsystem_totaltickets <- combine_email_and_tenant_data(dataset_relation, dataset_emails, dataset_tenants, 8, 13)
head(operatingsystem_totaltickets, n = 10)

```
* The distribution of pageviews per group
```{r}
library(dplyr)
#one to many
#dataset_emails$source_group
#dataset_pageviews$visits

pageviews_by_metric <- function(pageviews, emails, email_col_num){
    # save the column names for later
    old_email_name <- colnames(emails)[email_col_num]
    
    # rename the columns for ease of reference
    colnames(emails)[email_col_num] <- "email_col"
    
    # join tables, select and group columns and sum the number of pageviews
    group_pageview <- left_join(pageviews, emails, by='email_id') %>%
        select(email_id, visits, email_col) %>%
        group_by(email_col) %>%
        summarise(total_pageviews = sum(visits))
    
    # order descending by pageviews
    group_pageview <- arrange(group_pageview, -total_pageviews)
    
    # rename column back to old name
    colnames(group_pageview)[1] <- old_email_name
    
    return(group_pageview)
}

output <- pageviews_by_metric(dataset_pageviews, dataset_emails, 7)
output
top_results <- head(output, n = 8)
pie(top_results$total_pageviews, top_results$source_group, main="Pageviews by Source Group")
```
* The distribution differences on pageviews per login method
```{r}
library(dplyr)
#one to many
#dataset_emails$login_method
#dataset_pageviews$visits

# use function from previous exercise
output <- pageviews_by_metric(dataset_pageviews, dataset_emails, 11)
output
top_results <- head(output, n = 5)
pie(top_results$total_pageviews, top_results$login_method, main="Pageviews by Login Methods")
```
* What differences do you find between developers and non-developers?
```{r}
library(dplyr)
#dataset_emails$role
devs <- dataset_emails[dataset_emails$role == "developer",]
non_devs <- dataset_emails[dataset_emails$role == "non-developer",]
nrow(devs)
nrow(non_devs)
freq_devs <- as.data.frame(table(devs$browser))
freq_non_devs <- as.data.frame(table(non_devs$browser))
#head(freq_devs[order(freq_devs$browser),], n = 5)
#head(freq_non_devs[order(freq_non_devs$browser),], n = 5)
```
* What are the most and least used technologies in tenants?
```{r}
library(stringr)
tech <- as.vector(dataset_tenants$technologies_used)
tech <- tech[tech != ""]
comma_count <- sum(str_count(tech, ", "))
tech_reduced <- matrix(NA , nrow=length(tech) + comma_count, ncol=1, dimnames=list(NULL, c("tech_name")))
index <- 1
for (t in 1:length(tech)){
    if (grepl(", ", tech[t])){
        strings <- strsplit(tech[t], ", ")
        strings <- strings[[1]]
        for (s in 1:length(strings)){
            tech_reduced[index, 1] <- strings[s]
            index <- index + 1
        }
    } else {
        tech_reduced[index, 1] <- tech[t]
        index = index + 1
    }
}
tech_reduced <- as.data.frame(tech_reduced)
frequencies <- as.data.frame(lapply(tech_reduced, table))
head(frequencies[order(frequencies$tech_name.Freq),], n = 5)
head(frequencies[order(-frequencies$tech_name.Freq),], n = 5)
```
* Please mark any inconsistencies you find in the data that you'd research further if you were working at Auth0
```{r}
# dataset_emails$sperating_system has a typo
```
* Create at least 3 visualizations using R which you consider interesting for the provided data
```{r}

```
